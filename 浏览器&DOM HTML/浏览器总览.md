---
date created: 2021-12-09 22:59
date updated: 2021-12-17 16:51
---

#browser

## [[V8 引擎]]

## [[GC 机制]]
垃圾回收是一种内存管理机制. V8 中的垃圾回收器会尝试去分配已经不需要的对象所占据的内存控件. 比如在 JavaScript 拥有垃圾回收机制的语言中, 如果程序中仍然存在指向一个对象的引用, 那么该对象将不会被回收.
在大多数情况下, 我们没有必要去手动解除对象的引用(de-referencing). 只要简单地把变量放在它们该在的地方, GC 就可以正确的回收掉这些代码释放内存控件
注释: 在理想的情况下, 变量应该尽量为局部变量, 也就是说在它们被使用的函数中去声明它们.

## [[浏览器事件]]
JavaScript 和 HTML 的交互是通过**事件**实现的, 代表文档或浏览器窗口中发生特定交互的瞬间行为. 目前所有的现代浏览器都实现了 `DOM2 Events` 的核心部分, IE8 是最后一个使用专有事件系统的主流浏览器.
## [[浏览器存储]]

## [[HTTP 缓存]]
浏览器缓存也是HTTP是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点。接下来以三个部分来把浏览器的缓存机制说清楚：
- 强制缓存
- 协商缓存
- 缓存位置
[[缓存运用与最佳实践#浏览器的缓存策略]]
当一个用户发起一个静态资源请求的时候，浏览器会通过以下几步来获取资源：

1. **本地缓存阶段**：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送 http 请求到服务器；
2. **协商缓存阶段**：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个 http 请求到服务器,然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回 304，让浏览器使用本地找到的那个资源；[[Etag]]
3. **缓存失败阶段**：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本来没有找到资源)，服务器则返回该资源的数据，并且返回 200， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回 404。


## [[chrome 性能观察]]

## [[浏览器构成]]
现代浏览器一般采用多进程架构, 以 chrome 为例, 在浏览器中主要有以下几个进程:

1. **浏览器主进程** : 主要负责界面显示, 用户交互, 子进程管理, 提供用户存储等功能
2. **渲染进程(GPU 进程)** : 页面显示的关键进程, 主要将 HTML, CSS, javaScript 转化为页面, 使用排版引擎和 JS V8 引擎处理该类工作, 默认情况下, chrome 的一个 tab 就是一个渲染进程. 渲染进程运行在沙箱模式下. 该进程下又包含了以下几种重要的线程
   1. **GUI 渲染线程**
   2. **JS 引擎线程** 有 V8 引擎
   3. **事件触发线程** 与 EventLoop 密切相关
   4. **定时触发器线程**
   5. **异步 HTTP 请求线程**
## [[浏览器 EventLoop 事件循环]]
浏览器需要事件循环来协调事件、用户操作、脚本执行、渲染、网络请求等。通过事件循环，浏览器可以利用**任务队列**来管理任务，让异步事件**非阻塞**地执行。每个客户端对应的事件循环是相对独立的。
## [[浏览器渲染]]
**浏览器一个完整的渲染流程大致总结如下:**

- 渲染进程将 HTML 内容转换成 DOM tree
- 渲染引擎将 CSS 样式表转化为浏览器可理解的 styleSheet , 计算 DOM 节点的样式, 构建 CSSOM 样式树
- 创建布局树, 计算元素的布局信息
- 对每个图层生成绘制列表, 并将其提交到合成线程
- 合成线程将图层分成图块, 并在光栅化线程池中将图块转换成位图
- 合成线程发送绘制图块命令 DrawQuad 给浏览器进程
- 浏览器进程根据 DrawQuad 消息生成页面, 并显示到显示器
## [[浏览器回流与重绘]]

## [[浏览器跨域]]
**同源的定义**
如果两个 URL 的 [protocol](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol) 、[port (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Port "Currently only available in English (US)") (如果有指定的话)和 [host](https://developer.mozilla.org/zh-CN/docs/Glossary/Host) 都相同的话，则这两个 URL 是**同源**。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。
## [[webComponents]]

## [[Ajax]]
AJAX是异步的JavaScript和XML（**A**synchronous **J**avaScript **A**nd **X**ML）。简单点说，就是使用 [XMLHttpRequest](https://developer.mozilla.org/en-US/DOM/XMLHttpRequest) 对象与服务器通信。 它可以使用JSON，XML，HTML和text文本等格式发送和接收数据。AJAX最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。
## [[preload&prefetch]]

## [浏览器工作原理与实践](https://blog.poetries.top/browser-working-principle/guide/part5/lesson21.html#chrome-%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7)

## 总结：从输入URL到页面展示，这中间发生了什么

-   用户输入url并回车
-   浏览器进程检查url，组装协议，构成完整的url
-   浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
-   网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
-   **如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下**：
    -   进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）
    -   利用ip地址和服务器建立tcp连接
    -   构建请求头信息
    -   发送请求头信息
    -   服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
-   **网络进程解析响应流程**；
    -   检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步 （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
    -   200响应处理：检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。
-   **准备渲染进程**
    -   浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
-   **传输数据、更新状态**
    -   渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
    -   渲染进程接收完数据后，向浏览器发送“确认提交”
    -   浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面
