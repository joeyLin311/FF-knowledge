#Network
 [各种状态码](https://jelly.jd.com/article/6006b1035b6c6a01506c8791)
#### 300 Multiple Choices

客户端请求一个实际指向多个资源的 URL 时会返回这个状态码。

比如说，一个站点提供了中文和英文两个版本，理想情况下，服务器应当向中文用户发送中文版，向英文用户发送英文版。HTTP 提供了内容协商方法，允许客户端和服务器作这样的决定。内容协商包含客户端驱动的协商、服务器驱动的协商以及透明协商。

客户端驱动由客户端发起请求，服务器发送可选项的列表，客户端进行选择；服务器驱动是由服务器来检查客户端的请求首部集并决定提供提供哪个版本的页面（q 值机制，Vary 首部）；透明协商是由某个中间设备（通常是缓存代理）代表客户端进行请求协商。

而 300 Multiple Choices 属于客户端驱动的协商。服务器发送回 HTTP/1.1 响应时，使用 300 Multiple Choices 响应代码。客户端浏览器收到这种响应时，可能会弹出对话窗口，让用户选择。

#### 301 Moved Permanently

在请求的 URL 已被移除时使用。响应的 Location 首部中应该包含资源现在所处的 URL。

301 重定向是网页更改网址后对搜索引擎友好的最好方法，只要不是暂时搬移的情况，都建议使用 301 来做转址。比如说，我们将网页 a 的地址更改为 b，采用 301 重定向，搜索引擎可以肯定网页 a 永久性改变网址，搜索引擎就会把网页 b 当做唯一有效目标，同时，网页 a 积累的页面权重将被传到网页 b。(注：传递权重不同的搜索引擎不一样，Google 会传递大部分权重，但不是百分之百权重）

#### 302 Found

与 301 状态码类似，但是客户端应该使用 Location 首部给出的 URL 来临时定位资源，将来的请求仍应使用老的 URL。

一般 302 重定向是在一个网站或网页在短时间内临时移到其它位置的情况下使用，这时候就是做临时性的跳转了。

但是 302 跟网址“劫持”有着莫大的关系。大部分搜索引擎在大部分情况下，当收到 302 重定向时，一般只要去抓取目标网址即可。但是有时候搜索引擎（以 Google 为例）并不能总是抓取目标网址，比如说 a 网址很短，但是它做了 302 重定向到 b 网址，而 b 网址是一个很长的乱七八糟的 URL 网址，这时候 Google 很有可能仍显示网址 a，这时候就造成了网址劫持的可能性。如果一个居心叵测的人将一个网址 a 通过 302 重定向到你的网址 b，而 Google 搜索结果仍然是 A，这种情况就是网址劫持。同时，还容易导致网站被降权，所以尽量不用。

#### 303 See Other

用来告知客户端应该使用另一个 URL 来获取资源，新的 URL 位于响应报文的 Location 首部。

303 主要目的是允许 POST 请求的响应将客户端定位到某个资源上。比如说，在文件上传完成后让客户端自动重定向到一个上传成功的结果页面。

#### 304 Not Modified

如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器返回 304 状态码。304 响应不包含消息体，因此以消息头后的第一个空行结尾。

在一条 HTTP GET 请求中，大致是如下的一个过程

![](https://img20.360buyimg.com/ling/jfs/t1/59428/40/2154/46331/5d077c6fE766c1e12/21aa5bbc502b6c5c.png)

在查看本地副本是否过期时，通过检查 Cache-Control 或者 Expires 首部即可获知。HTTP 通过 Cache-Control 首部和 Expires 首部向每个文档附加了一个“过期日期”，在缓存文档过期之前，缓存可以以任何频率使用这些副本，而无需与服务器联系。

Expires 首部是 HTTP/1.0 定义的字段，指定的是一个绝对的过期日期。而 Cache-Control 是 HTTP/1.1 定义的字段，max-age 值定义了文档的最大使用值，是相对时间。因为绝对时间需要依赖于计算机时钟的正确设置，容易存在误差。所以，我们更倾向于使用比较新的 Cache-Control 首部。当同时存在 Expires 和 Cache-Control: max-age 字段时，Cache-Control: max-age 字段会覆盖 Expires 字段。同时存在这两个字段还有一个好处，就是可以兼容 HTTP/1.0。

本地缓存过期了并不意味着它和原始服务器上目前处于活跃状态的文档有实际的区别，这时候缓存需要询问原始服务器文档是否发生了改变，跟原始服务器做一次 **新鲜度校验**。

HTTP 条件方法可以高效地实现再验证。通过 If-Modified-Since 或者 If-None-Match 首部来校验。

**If-Modified-Since: Date 再验证**：If-Modified-Since 首部可以和 Last-Modified 服务器响应首部配合工作。原始服务器会将最后的修改日期附加到所提供的文档上去。

**If-None-Match: 实体标签再验证**：有些文档可能被被周期性的重写、有些文档可能被修改了但所做修改不重要等等这类情况下，使用最后修改日期进行再验证是不够的，这时候 HTTP 允许用户对被称为实体标签 ETag 的“版本标识符”进行比较。

实体标签和最近修改日期都是缓存验证器，如果服务器回送了一个实体标签，HTTP/1.1 客户端就必须使用实体标签验证器。如果只返回了一个 Last-Modified 值，客户端就可以使用 If-Modified-Since 验证。如果实体标签和最后修改日期都提供了，客户端就应该使用这两种再验证方案，这样 HTTP/1.0 和 HTTP/1.1 缓存就都可以正确响应了。如果 HTTP/1.1 服务器收到的请求既带有 If-Modified-Since，又带有 ETag 条件首部，那么需要这两个条件都满足时，才能返回 304 Not Modified 响应。

#### 305 Use Proxy

用来说明必须通过一个代理来访问资源，代理的位置由 Location 首部给出。

客户端是相对某个特定资源来解析这条响应的，不能假定所有请求，甚至所有对特有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误地让代理介入了某条请求，可能会引发破坏性行为，而且会造成安全漏洞。所以，305 这个状态码也较少使用。

#### 306 unused

在 HTTP1.1 废弃掉了，不再使用，并且此状态码被保留。在 HTTP1.1 以前的版本中，306 Switch Proxy 用于表示随后的请求应该使用指定的代理。

#### 307 Temporary Redirect

请求的资源临时从不同的 URI 响应请求，客户端应该使用 Location 首部给出的 URL 来临时定位资源。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。

除非是一个 HEAD 请求，否则 307 响应的实体中应当包含指向新的 URL 的超链接及简短说明。因为部分浏览器不能识别 307 响应，添加 URL 超链接以便不能处理 307 状态码的用户有能力在新 URL 中发起重定向请求，也就是说，把重定向的页面展示给用户，让用户去点重定向 URL 链接。

![](https://img13.360buyimg.com/ling/jfs/t1/55143/14/2670/12895/5d077cb8Eb2e271e0/c241b325dd0cfadb.png)

我们可以看到 Chrome 对于 hsts 列表的域名，采用了 307 进行重定向。

以上内容讲述了 301-307 的状态码，对于这些状态码以及一些缓存的首部可能还有一些疑惑，以下简单地列出了几点。

#### 1、从上面的状态码中，你可能注意到 302、303 和 307 状态码之间存在一些交叉，那么，它们之间存在哪些细微差别？

303 和 307 是 HTTP/1.1 新增加的状态码，它们是对 HTTP1.0 中的 302 状态码的细化。当 HTTP/1.0 客户端发起一个 POST 请求，并在响应中收到 302 重定向状态码时，它会接受 Location 首部的重定向 URL，并向那个 URL 发起一个 GET 请求。透过以上的状态码介绍，我们可以发现 HTTP/1.1 规范使用 303 状态码来实现同样的行为。为了避开这个问题，对于 HTTP/1.1 客户端，用 307 状态码来代替 302 状态码进行临时重定向。

在 HTTP/1.1 中，302 理论上是可以被 303 和 307 代替掉的，但为了兼容 HTTP/1.0，依然还在广泛使用。

#### 2、经常可以看到 **_Cache-Control: no-cache_** 这样的首部，那么代表的是不缓存么？

Cache-Control: no-cache 响应实际上是可以存储到本地缓存区中的，只是在与服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。

如果需要本地彻底不缓存，需要使用 Cache-Control: no-store，表示缓存应该尽快从存储器中删除文档的所有痕迹。
