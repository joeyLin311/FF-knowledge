# JavaScript 浮点数计算精度问题

### 浮点数运算后的精度

```jsxx
// 加法 =====================
0.1 + 0.2 = 0.30000000000000004
0.7 + 0.1 = 0.7999999999999999
0.2 + 0.4 = 0.6000000000000001

// 减法 =====================
1.5 - 1.2 = 0.30000000000000004
0.3 - 0.2 = 0.09999999999999998
 
// 乘法 =====================
19.9 * 100 = 1989.9999999999998
0.8 * 3 = 2.4000000000000004
35.41 * 100 = 3540.9999999999995

// 除法 =====================
0.3 / 0.1 = 2.9999999999999996
0.69 / 10 = 0.06899999999999999

```

### toFinxed() 的精度问题

[Number.prototype.toFixed()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)

```jsxx
1.35.toFixed(1) // 1.4 正确
1.335.toFixed(2) // 1.33  错误
1.3335.toFixed(3) // 1.333 错误
1.33335.toFixed(4) // 1.3334 正确
1.333335.toFixed(5)  // 1.33333 错误
1.3333335.toFixed(6) // 1.333333 错误
```

---

## 产生这个问题的原因

### 浮点数的存储

和其它语言如 Java, Python 不同, JavaScript 中所有数字包括整数和小数都只有一种类型 —— Number. 它的实现遵循 [IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754) 标准, 使用 64 位固定长度来表述, 也就是标准的 double 双精度浮点数.

这种的存储结构有点是可以归一化处理整数和小数, 节省储存空间.

64 位比特可以分为三部分:

- 符号位 S : 第一位是正负数符号位(sign), 0 代表整数, 1 代表附属
- 指数位 E : 中间的 11 位存储职位(exponent), 用来表示次方数
- 尾数位 M : 最后的 52 位是尾数(mantissa), 超出的部分自动进一舍零

---

### JS 浮点数运算分析

在 JavaScript 计算浮点值的过程中, 会将十进制的浮点数转换成二进制的, 但是由于浮点数用二进制表示时是无穷的:

- 0.1 + 0.2 为例

```jsxx
0.1 -> 0.0001 1001 1001 1001...(1100 循环)
0.2 -> 0.0011 0011 0011 0011...(0011 循环)
```

IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制位, 所以两者相加后得到的二进制为:

```jsxx
0.0100110011001100110011001100110011001100110011001100
```

因为浮点小数位的限制而阶段的二进制数字, 再转换为十进制, 就变成了 0.30000000000000004. 所以在进行算术计算时就会产生误差.

## 解决方法

### 数据展示类

当拿到形如 `1.200000000000333` 这样的数据展示时, 可使用 `toPrecision` 凑整并使用 `parseFloat` 转成数字类型显示:

```jsxx
parseFloat(1.200000000000333.toPrecision(12)) === 1.2 // true
```

封装方法:

```jsxx
function strip(num, precision = 12) {
  return +parseFloat(num.toPrecision(precision));
}
```

<aside>
💡 其中选择 `12`  作为默认精度, 只是一种经验选择, 一般选择 12 就能解决大部分数据展示的问题. It depends.

</aside>

### 数据展示类

对于运算类操作: 加减乘除 `+-*/` , 就不能使用 `toPrecision` . 应该把小数转成整数后再运算:

```jsxx
/**
 * 精确加法
 */
function add(num1, num2) {
  // 获取数字小数点长度
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  console.log(num1Digits, num2Digits)
  // 比较两数末尾最大值成为幂值 得出基数
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  console.log(baseNum)
  // 数字运算, 先乘以基数相加变为整数, 再除以基数
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}
```

<aside>
💡 以上方法能适用于大部分场景。遇到科学计数法如 2.3e+1（当数字精度大于21时，数字会强制转为科学计数法形式显示）时还需要特别处理一下。

</aside>
