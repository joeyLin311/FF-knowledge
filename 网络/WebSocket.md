---
date created: 2022-05-12 22:38
---

## 介绍

WebSocket 协议是 HTML5 的一种新协议, 属于应用层. 它实现了浏览器与服务器全双工通信.  一开始的握手需要借助 HTTP 请求完成.

### 目的: 即时通讯, 代替轮询

比如实时聊天系统, 视频播放, 以往这种技术通常是采用轮询, Comet(?)技术解决的.
传统的 HTTP 协议是非持久化的, 无状态的, 单向的网络协议, 在简历链接之后只允许浏览器向服务器发出请求并响应数据. **这种模式会导致过多的不必要的请求, 浪费流量和服务器资源, 每一次请求/应答, 都浪费了一定的资源在头部信息上**
WebSocket 的出现可以幕布这一缺点, 在 WebSocket 中, 只需要服务器和浏览器通过 HTTP 协议进行一个握手动作, 即可单独联机一条 TCP 链接进行数据传送并且是双向的.
![[WebSocket 连接.png]]

## Websocket优点

Websocket协议相比http优势很明显，首先在效率上有多方面的提升。

- 传统的http请求，其并发能力都是依赖同时发起多个TCP连接访问服务器实现的(因此并发数受限于浏览器允许的并发连接数)，而websocket则允许我们在一条ws连接上同时并发多个请求，即在A请求发出后A响应还未到达，就可以继续发出B请求。由于TCP的慢启动特性（新连接速度上来是需要时间的），以及连接本身的握手损耗，都使得websocket协议的这一特性有很大的效率提升。
- http协议的头部太大，且每个请求携带的几百上千字节的头部大部分是重复的，很多时候可能响应都远没有请求中的header空间大。如此多无效的内容传递是因为无法利用上一条请求内容，websocket则因为复用长连接而没有这一问题。
- websocket支持服务器推送消息，这带来了及时消息通知的更好体验，也是ajax请求无法达到的。

## Websocket缺点

- 服务器长期维护长连接需要一定的成本,各个浏览器支持程度不一
- websocket 是长连接，受网络限制比较大，需要处理好重连，比如用户进电梯或电信用户打个电话网断了，这时候就需要重连

## 和 Socket 的区别

- Socket 其实并不是一个协议. 它工作在 OSI 模型会话层(第5层), 是为了方便大家直接使用更底层协议(一般是 TCP 或 UDP)而存在的一个抽象层.
- WebSocket 是应用层协议, 它是包装成了一个应用层协议作为 socket , 从而使客户端和服务器通过web 建立全双工通信, WebSocket 提供ws和wss两种URL方案

```markup
ws://example.com:80/some/path
```

![[ws-wss连接.jpg]]

## 和HTTP的区别

### 相同:

- 都是基于TCP的应用层协议
- WebSocket 是需要浏览器和服务器握手建立链接的,都使用Request/Response模型进行连接的建立
- WebSocket 是双向通信协议, 模拟 Socket 协议, 可以双向发送或接受消息, HTTP 是单向的
- 在连接的建立过程中对错误的处理方式相同，在这个阶段WS可能返回和HTTP相同的返回码

### 不同:

- WebSocket **没有同源限制**, 客户端可以和任意服务器通信
- WS使用HTTP来建立连接，但是定义了一系列新的header域，这些域在HTTP中并不会使用
- WS是HTML5中的协议，支持持久连接；而Http协议不支持持久连接
- WS连接建立之后，数据的传输使用帧来传递，不再需要Request消息
- WS的数据帧有序

### 和HTTP2 的区别
![[WebSocket-VS-HTTP2.jpg]]
虽然HTTP2 引入了服务端推送, 使服务器能够主动将资源发送到客户端缓存. 但是它不允许将数据推送到客户端应用程序本身. 服务器推送仅由浏览器处理, 不会弹出到应用程序代码, 这意味着应用程序没有 API 来获取这些时间的通知. 

## WebSocket 握手阶段是通过什么协议传输的？握手成功后会返回一个什么状态？200吗？
ws 握手阶段采用的是http协议。  
readyState 属性返回实例对象的当前状态，共有四种:

-   CONNECTING：值为 0，表示正在连接。
-   OPEN：值为 1，表示**连接成功**，可以通信了。
-   CLOSING：值为 2，表示连接正在关闭。
-   CLOSED：值为 3，表示连接已经关闭，或者打开连接失败。

返回的的状态码为 101 [[HTTP 状态码#101 Switching Protocols]]

## WebSocket 传输文件的思路
1. 服务器侦听某端口, 接收 WebSocket 请求, 后面可用 Nginx 做反向代理, 外部看到的是 80 端口
2. 客户端连接服务器的 WebSocket 地址, 连接成功后先发送一个 NEE_FILE 的数据包, 里面戴上要传输的文件名
3. 服务器接收到NEW_FILE 之后, 解析出文件名并且创建目标文件. 再回复ACK_NEW_FILE的数据包
4. 客户端收到ACK_NEW_FILE的数据包后, 查回应的code, 如是成功码则启动一个线程. 该线程负责将源文件的数据封装成多个FILE_DATA数据包, 传送这些FILE_DATA数据至服务器端
5. 服务器端接收FILE_DATA数据包, 解析出里面的文件数据, 将文件数据写入文件
6. 客户端发送完源文件数据后, 再传送一个FILE_END数据包, 该文件包中带上源文件的MD5值
7. 服务器端收到FILE_END数据包后，比对源文件的MD5值与目标文件的MD5值，如相同，则认为传输成功，并返回ACK_FILE_END数据包，里面带上成功码
8. 客户端收到 ACK_FILE_END 数据包, 检查回应的 code , 如果是成功码则认为成功, 否则认为失败
### 数据传输过程中出现粘包, 是怎么回事

  发生TCP粘包或拆包有很多原因，现列出常见的几点，可能不全面，欢迎补充，
  1. 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。
  2. 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。
  3. 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。
  4. 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。
  5. 等等。

### 粘包、拆包解决办法
通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：

1. 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
2. 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
3. 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。
4. 