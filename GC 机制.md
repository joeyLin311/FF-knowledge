---
date created: 2021-12-09 22:56
date updated: 2021-12-17 16:06
---

#browser

## GC 机制-垃圾回收

垃圾回收是一种内存管理机制. V8 中的垃圾回收器会尝试去分配已经不需要的对象所占据的内存控件. 比如在 JavaScript 拥有垃圾回收机制的语言中, 如果程序中仍然存在指向一个对象的引用, 那么该对象将不会被回收.
在大多数情况下, 我们没有必要去手动解除对象的引用(de-referencing). 只要简单地把变量放在它们该在的地方, GC 就可以正确的回收掉这些代码释放内存控件
注释: 在理想的情况下, 变量应该尽量为局部变量, 也就是说在它们被使用的函数中去声明它们.

## 描述引用计数的工作原理和优缺点

引用计数 是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量改变了引用对象，则该值引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值，从而就可以将其占用的内存进行回收。这样，但 GC 算法下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。缺点是可能会循环应用, 当 AB 对象相互应用时, 函数执行完之后, 两者的引用次数不会变成 0, 这种情况会导致内存泄漏.

## 描述标记整理算法的工作流程

变量进入环境时, 标记整理算法就会标记该变量"进入环境". 当变量离开环境时, 标记变量为"离开环境". 垃圾收集器去掉运行环境中的变量以及变量所引用的变量的标记, 如果标量依然有标记就被视为可删除的变量, 在此时运行环境中已经无法访问到这些变量. 最后垃圾收集器完成内存清楚工作, 销毁带标记的值并回收所占的内存空间.

## 描述 V8 中新生代存储区垃圾回收的流程

V8 将内存分为新生代区和老生代区, 新生代存储区有 From 空间和 To 空间, 在 From 空间中 GC 判断对象是否被引用, 如果对象有被引用视为活跃对象, 复制到 To 空间, 然后清空 From 空间的内存. 接着交换 From 空间和 To 空间, From 空间继续有新增对象, 没有被引用的对象继续停留在 From 空间, 其它进入 To 空间, 再清除 From 空间. 然后开始下一轮.

## 描述增量标记算法在何时使用及工作原理

上述提到新生代和老生代区是 V8 设置的两个内存空间, 在对象多次回收后依然存在的话, 就会进去老生代区. 如果老生代区的垃圾回收任务繁重, 会影响应用性能, 为了避免性能问题, V8 此时会采用增量标记算法. 增量标记算法将 GC 的一次回收步骤分成若干个小步骤, 前后多次穿插执行垃圾回收. 以此减少 GC 的主进程的阻塞.
[[内存管理]]
